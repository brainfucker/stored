package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

const prefix = `// Code generated by STORED DO NOT EDIT.`
const postfix = `// End of STORED generated code`

// Generator used collected info to generate stored code
type Generator struct {
	file *File
	pos  int
}

func (g *Generator) setPosition(file *File, pos int) {
	g.file = file
	g.pos = pos
}

func (g *Generator) cutOldCode(code string) (string, error) {
	for {
		cutStart := strings.Index(code, prefix)
		if cutStart == -1 {
			break
		}

		cutEnd := strings.Index(code, postfix)
		if cutEnd == -1 {
			return code, errors.New("old code closing tag «" + postfix + "» not found")
		}
		cutEnd += len(postfix)
		if len(code) > cutEnd {
			cutEnd++
		}
		code = code[:cutStart] + code[cutEnd:]
		if cutStart < g.pos {
			g.pos -= cutEnd - cutStart
			if cutEnd > g.pos {
				return code, errors.New("//go:generate tag in inside already generated code block, please place //go:generate at the top of file")
			}
		}

	}
	return code, nil
}

func (g *Generator) write(src string) {
	if g.file == nil {
		fmt.Printf("no generate tag found, please put this tag in your code //go:generate $GOPATH/bin/stored")
		return
	}
	codeBytes, err := ioutil.ReadFile(g.file.name)
	if err != nil {
		fmt.Printf("could not read file «%s»: %v", g.file.name, err)
		return
	}
	code := string(codeBytes)
	code, err = g.cutOldCode(code)
	if err != nil {
		fmt.Println("new code ERRR", err)
		fmt.Printf("%s", err)
		return
	}

	code = code[0:g.pos] + src + code[g.pos:]
	//lines := bytes.Split(b, []byte{'\n'})

	err = ioutil.WriteFile(g.file.name, []byte(code), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *Generator) generateUtil() string {
	return `
func _stored_vInt(writer io.Writer, v int) error {
	var _stored_vInt_buf = make([]byte, 8)
	l := binary.PutUvarint(_stored_vInt_buf, uint64(v))
	_, err := writer.Write(_stored_vInt_buf[:l])
	return err
}`
}

// generate triggers code generation
func (g *Generator) generate(blocks []string) {
	src := "\n\n" + prefix + "\n/*" + g.generateUtil()
	for _, block := range blocks {
		src += "\n" + block
	}
	src += "*/\n" + postfix
	g.write(src)
}
